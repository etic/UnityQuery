using UnityEngine;
using System.Collections;
using System.Collections.Generic;
using System.Linq;

namespace UnityQuery {

    public class UQObject : IEnumerable<GameObject> {

        /// <summary>
        /// The list of GameObjects this UQObject represents.
        /// </summary>
        private List<GameObject> gameObjects;

        /// <summary>
        /// The head of the UQObject's selector chain.  This is the UQObject
        /// returned by <code>End()</code>.  For a UQObject generated by a selector,
        /// this is the UQObject of the first selector in the current UQObject's
        /// selector chain.  For a UQObject generated by an action, this is the
        /// UQObject of the most recent selector relative to the current UQObject.
        /// The first UQObject of any query is always its own head.
        /// </summary>
        private UQObject head;

        public GameObject this[int i] {
            get { return gameObjects[i]; }
        }

        public IEnumerator<GameObject> GetEnumerator() {
            return gameObjects.GetEnumerator();
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        /// <summary>
        /// Creates an empty UQObject with the given head.
        /// <param name="head">The head of the UQObject.</param>
        /// </summary>
        public UQObject(UQObject head=null) {
            gameObjects = new List<GameObject>();
            this.head = head ?? this;
        }

        /// <summary>
        /// Creates a new UQObject with the given GameObjects and head. 
        /// <param name="gameObjects">The GameObjects list of the UQObject.</param>
        /// <param name="head">The head of the UQObject.</param>
        /// </summary>
        public UQObject(IEnumerable<GameObject> gameObjects, UQObject head=null) {
            this.gameObjects = gameObjects.ToList<GameObject>();
            this.head = head ?? this;
        }

        /// <summary>
        /// Instantiates a UQObject with the current UQObject's head.
        /// <param name="gameObjects">The GameObjects list of the UQObject.</param>
        /// </summary>
        private UQObject WithHead(IEnumerable<GameObject> gameObjects) {
            return new UQObject(gameObjects, head);
        }

        #region Selector methods

        /// <summary>
        /// Returns the children of all GameObjects in the current list.
        /// </summary>
        public UQObject Children() {
            return WithHead(gameObjects
                .SelectMany(x => {
                    if (x.transform.childCount == 0) {
                        return null;
                    } else {
                        return Enumerable.Range(0, x.transform.childCount)
                                         .Select(n => x.transform.GetChild(n));
                    }
                })
                .Distinct()
                .OfType<GameObject>());
        }

        /// <summary>
        /// Returns all descendants of all GameObjects in the current list.
        /// </summary>
        public UQObject Descendants() {
            return WithHead(gameObjects
                .SelectMany(x => x.GetComponentsInChildren<Transform>())
                .Distinct()
                .Select(x => x.gameObject));
        }

        /// <summary>
        /// Returns the result of the most recent selector chain relative to the
        /// current UQObject.
        /// </summary>
        public UQObject End() {
            return head;
        }

        /// <summary>
        /// Returns all GameObjects from the current list with the given name.
        /// </summary>
        public UQObject WithName(string name) {
            return WithHead(gameObjects.Where(x => x.name == name));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with the given layer.
        /// <param name="layer">The name of the layer.</param>
        /// </summary>
        public UQObject WithLayer(string layer) {
            return WithLayer(LayerMask.NameToLayer(layer));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with the given layer.
        /// <param name="layer">The value of the layer.</param>
        /// </summary>
        public UQObject WithLayer(int layer) {
            return WithHead(gameObjects.Where(x => x.layer == layer));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with the given tag.
        /// <param name="tag">The name of the tag.</param>
        /// </summary>
        public UQObject WithTag(string tag) {
            return WithHead(gameObjects.Where(x => x.tag == tag));
        }

        /// TODO: all the other versions of a thing where you have to specify a type (ugh)
        /// <summary>
        /// Returns all GameObjects from the current list with a Component that has
        /// the given type.
        /// <typeparam name="T">The type of Component to search for.</typeparam>
        /// </summary>
        public UQObject WithComponent<T>() where T : Component {
            return WithHead(gameObjects.Where(x => x.GetComponent<T>() != null));
        }

        /// <summary>
        /// Returns all GameObjects from the current list that are active in the
        /// scene.
        /// </summary>
        public UQObject Active() {
            return WithHead(gameObjects.Where(x => x.activeInHierarchy));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with a local active state
        /// set to true.
        /// </summary>
        public UQObject ActiveSelf() {
            return WithHead(gameObjects.Where(x => x.activeSelf));
        }

        /// <summary>
        /// Returns all GameObjects from the current list that are not active in the
        /// scene.
        /// </summary>
        public UQObject Inactive() {
            return WithHead(gameObjects.Where(x => !x.activeInHierarchy));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with a local active state
        /// set to false.
        /// </summary>
        public UQObject InactiveSelf() {
            return WithHead(gameObjects.Where(x => !x.activeSelf));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with renderers that have
        /// visibility equal to the given value.
        /// <param name="visible">The value of the renderer's visibility.</param>
        /// </summary>
        public UQObject Visible(bool visible=true) {
            return WithHead(gameObjects
                .Where(x => x.GetComponent<Renderer>() != null
                         && x.GetComponent<Renderer>().isVisible == visible));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with a renderer that is
        /// not visible.
        /// </summary>
        public UQObject Hidden() {
            return Visible(false);
        }

        /// <summary>
        /// Returns all GameObjects from the current list that have no children.
        /// </summary>
        public UQObject Empty() {
            return WithHead(gameObjects.Where(x => x.transform.childCount == 0));
        }

        /// <summary>
        /// Returns all GameObjects from the current list with an even child index.
        /// Zero-indexed.
        /// </summary>
        public UQObject Even() {
            return NthChild(2, 2);  
        }

        /// <summary>
        /// Returns all GameObjects from the current list with an odd child index.
        /// Zero-indexed.
        /// </summary>
        public UQObject Odd() {
            return NthChild(1, 2);
        }

        /// <summary>
        /// Returns all GameObjects from the current list that are the first
        /// child of their parent.
        /// </summary>
        public UQObject FirstChild() {
            return NthChild(1);
        }

        /// <summary>
        /// Returns all GameObjects from the current list that are the first
        /// child of their parent with a component of the given type.
        /// <typeparam name="T">The type of the Component to search for.</typeparam>
        /// </summary>
        public UQObject FirstChildWithComponent<T>() where T : Component {
            return NthChildWithComponent<T>(1);
        }

        /// <summary>
        /// Returns all GameObjects from the current list that are the nth-child
        /// of their parent.
        /// <param name="index">The starting index of each child to match.</param>
        /// <param name="repeat">TODO: THIS IS HARD</param>
        /// </summary>
        public UQObject NthChild(int index, int repeat=0) {
            return WithHead(gameObjects
                .Where(x => {
                    Transform parent = x.transform.parent;
                    if (parent == null) {
                        return false;
                    }
                    for (int i = index; i < parent.childCount; i += repeat) {
                        if (parent.GetChild(i) == x.transform) {
                            return true;
                        }
                        if (repeat <= 0) {
                            return false;
                        }
                    }
                    return false;
                }));
        }

        /// <summary>
        /// Returns all GameObjects from the current list that are the nth-child
        /// of their parent with a component of the given type.
        /// <typeparam name="T">The type of the Component to search for.</typeparam>
        /// <param name="index">The starting index of each child to match.</param>
        /// <param name="repeat">TODO</param>
        /// </summary>
        public UQObject NthChildWithComponent<T>(int index, int repeat=0) where T : Component {
            return WithHead(gameObjects
                .Where(x => {
                    Transform parent = x.transform.parent;
                    if (parent == null) {
                        return false;
                    }
                    int withComponentIndex = 0;
                    foreach (Transform child in parent) {
                        if (child.GetComponent<T>() != null) {
                            bool validIndex = repeat <= 0 
                                                  ? withComponentIndex == index
                                                  : (withComponentIndex - index) % repeat == 0;
                            if (validIndex) {
                                if (child == x.transform) {
                                    return true;
                                }
                                if (repeat <= 0) {
                                    return false;
                                }
                            }
                            withComponentIndex++;
                        }
                    }
                    return false;
                }));
        }

        public UQObject NthLastChild(int index, int repeat=0) {
            return WithHead(gameObjects
                .Where(x => {
                    Transform parent = x.transform.parent;
                    if (parent == null) {
                        return false;
                    }
                    for (int i = parent.childCount - index; i >= 0; i -= repeat) {
                        if (parent.GetChild(i) == x.transform) {
                            return true;
                        }
                        if (repeat <= 0) {
                            return false;
                        }
                    }
                    return false;
                }));
        }

        public UQObject NthLastChildWithComponent(int index, int repeat=0) {
            Debug.LogWarning("Not implemented");
            return null;
        }

        public UQObject OnlyChild() {
            return WithHead(gameObjects
                .Where(x => x.transform.parent != null && x.transform.parent.childCount == 1));
        }

        public UQObject OnlyWithComponent<T>() where T : Component {
            return WithHead(gameObjects
                .Where(x => {
                    if (x.transform.parent == null || x.GetComponent<T>() == null) {
                        return false;
                    }
                    foreach (Transform child in x.transform.parent) {
                        if (child != x.transform && child.GetComponent<T>() != null) {
                            return false;
                        }
                    }
                    return true;
                }));
        }

        public UQObject IsParent() {
            return WithHead(gameObjects.Where(x => x.transform.childCount > 0));
        }

        public UQObject Parents() {
            return WithHead(gameObjects
                .Where(x => x.transform.parent != null)
                .Select(x => x.transform.parent.gameObject));
        }

        public UQObject Next() {
            return WithHead(gameObjects
                .Where(x => x.transform.parent != null)
                .Select(x => {
                    Transform parent = x.transform.parent;
                    for (int i = 0; i < parent.childCount; i++) {
                        if (parent.GetChild(i) == x.transform) {
                            if (i == parent.childCount - 1) {
                                return null;
                            } else {
                                return parent.GetChild(i + 1).gameObject;
                            }
                        }
                    }
                    return null;
                })
                .Distinct()
                .OfType<GameObject>());
        }

        public UQObject NextAll() {
            return WithHead(gameObjects
                .Where(x => x.transform.parent != null)
                .SelectMany(x => {
                    Transform parent = x.transform.parent;
                    for (int i = 0; i < parent.childCount; i++) {
                        if (parent.GetChild(i) == x.transform) {
                            if (i == parent.childCount - 1) {
                                return null;
                            } else {
                                return Enumerable.Range(i + 1, parent.childCount - i + 1)
                                                 .Select(n => parent.GetChild(n).gameObject);
                            }
                        }
                    }
                    return null;
                })
                .Distinct()
                .OfType<GameObject>());
        }

        public UQObject Prev() {
            return WithHead(gameObjects
                .Where(x => x.transform.parent != null)
                .Select(x => {
                    Transform parent = x.transform.parent;
                    for (int i = parent.childCount - 1; i >= 0; i--) {
                        if (parent.GetChild(i) == x.transform) {
                            if (i == 0) {
                                return null;
                            } else {
                                return parent.GetChild(i - 1).gameObject;
                            }
                        }
                    }
                    return null;
                })
                .Distinct()
                .OfType<GameObject>());
        }

        public UQObject PrevAll() {
            return WithHead(gameObjects
                .Where(x => x.transform.parent != null)
                .SelectMany(x => {
                    Transform parent = x.transform.parent;
                    for (int i = parent.childCount - 1; i >= 0; i--) {
                        if (parent.GetChild(i) == x.transform) {
                            if (i == 0) {
                                return null;
                            } else {
                                return Enumerable.Range(0, i)
                                                 .Select(n => parent.GetChild(n).gameObject);
                            }
                        }
                    }
                    return null;
                })
                .Distinct()
                .OfType<GameObject>());
        }

        public UQObject Roots() {
            return WithHead(gameObjects
                .Select(x => x.transform.root.gameObject)
                .Distinct());
        }

        // http://answers.unity3d.com/questions/27729/finding-the-root-gameobjects-in-the-scene-.html
        // slow with big scenes (traverses every object)
        public UQObject AllRoots() {
            List<GameObject> rootObjects = new List<GameObject>();
            foreach (GameObject obj in Object.FindObjectsOfType(typeof(GameObject))) {
                if (obj.transform.parent == null) {
                    rootObjects.Add(obj);
                }
            }
            return WithHead(rootObjects);
        }

        public IEnumerable<T> AddComponent<T>() where T : Component {
            return gameObjects.Select(x => x.AddComponent<T>());
        }

        public IEnumerable<T> GetComponent<T>() where T : Component {
            return gameObjects.Select(x => x.GetComponent<T>());
        }

        public UQObject Duplicate() {
            Debug.LogWarning("Not implemented");
            return null;
        }

        public UQObject Siblings() {
            Debug.LogWarning("Not implemented");
            return null;
        }

        #endregion

        #region Actions

        public UQObject AddChild(GameObject prefab = null) {
            Debug.LogWarning("Not implemented");
            return null;
        }

        public UQObject AddSibling(GameObject prefab = null) {
            Debug.LogWarning("Not implemented");
            return null;
        }

        public UQObject Destroy() {
            gameObjects.ForEach(x => Object.Destroy(x));
            return WithHead(new List<GameObject>());
        }

        public UQObject ForEach(System.Action<GameObject> action) {
            foreach (GameObject go in gameObjects) {
                action(go);
            }
            return WithHead(gameObjects);
        }

        public UQObject ForEach<T>(System.Action<T> action) where T : Component {
            foreach (GameObject go in gameObjects) {
                T component = go.GetComponent<T>();
                if (component != null) {
                    action(component);
                }
            }
            return WithHead(gameObjects);
        }

        #endregion

    }

}